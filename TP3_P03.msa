*****************************************************************************************************************
*		TP3	EJERCICIO 3			GRUPO B 4						*
*														*
* Consigna:													*
* 	Crear un arreglo bidimensional de 4 x 3 celdas, las mismas contienen números no signados de 16 bits.	*
* 	Escribir la subrutina get_cell que retorne el valor cualquiera de una celda de la matriz de 4x3. La 	*
* 	subrutina deberá devolver el valor en el registro D, recibirá por stack la dirección de comienzo de la 	*
* 	matriz, el número de fila y columna. La primera fila/columna del arreglo se indica con el número cero, 	*
*	mientras que la última con el 3/2. La función deberá invocar a la subrutina chk¬_status que verificará 	*
*	que los valores de fila y columna sean válidos. La forma de recepción y envío de parámetros a chk_status*
*	la definirá cada grupo según crea más conveniente. Se exige documentación clara al respecto. 		*
* 	La función get_cell devuelve el flag de carry en uno si ocurrió un error y en cero si se pudo obtener el*
* 	valor deseado.												*
* 	Trabajar con constantes simbolicas en el desarrollo de las funciones.					*
*****************************************************************************************************************
	p68h11

*********************************************************
*		ZONA DE CONSTANTES			*
* Se definen los valores numericos constantes utilizados*
* a lo largo del programa.				*
*********************************************************
TAM_STK	EQU	32		tamaño del stack
FILAS	EQU	4		cantidad total de filas de la matriz
COLS	EQU	3		cantidad total de columnas de la matriz
TAM_CEL	EQU	2		tamaño de cada celda (cantidad de bytes)
N_FIL	EQU	FILAS-1		cálculo de la última fila
N_COL	EQU	COLS-1		cálculo de la última columna
SEEKF	EQU	2		valor ingresado para buscar el nro de fila
SEEKC	EQU	1		valor ingresado para buscar el nro de columna
TAM_FIL	EQU	TAM_CEL*COLS	cálculo del tamaño de una fila
RAM	EQU	$3000		posicion de memoria volatil (matriz y stack)
DATOOUT	EQU	$3400		posición de memoria en la que se guarda el valor devuelto por get_cell

*********************************************************
*		PROGRAMA PRINCIPAL			*
*********************************************************
	org	$2000		zona de memoria del MAIN
main	EQU	*
	lds	#stk_ini	inicializo el stack

	ldaa	#N_FIL		
	psha			paso el nro de la ultima fila por el stack
	ldaa	#N_COL
	psha			paso el nro de la ultima columna por el stack
	ldaa	#SEEKF
	psha			paso el nro de la fila a buscar por el stack
	ldaa	#SEEKC
	psha			paso el nro de la columna a buscar por el stack
	ldaa	#TAM_CEL
	psha			paso el valor del tamaño de cada celda por el stack
	ldaa	#TAM_FIL
	psha			paso el valor del tamaño de cada fila por el stack
	ldx	#matriz
	pshx			paso la posicion de memoria de la matriz por el stack

	jsr	get_cell	voy a la subrutina get_cell

	pulx			Libero 8 bytes del stack
	pulx
	pulx
	pulx

	std	DATOOUT		guardo el valor recuperado en la posicion de memoria declarada

fin	jmp	fin		bucle infinito, fin del programa

*****************************************************************************************
*		SUBRUTINA GET_CELL							*
* Objetivo: Obtener el valor de la celda de una matriz de F filas por C columnas, cuyos	*
*	elementos (celdas) tienen un tamaño de 2 bytes cada uno.			*
* Outputs:										*
*	1) Devuelve el valor del elemento buscado por el registro D			*
*											*
* Inputs (Parámetros de entrada, deben ser pasados a través del stack):			*
*	1) N_FIL: Índice de la última fila (contando el cero). [1 byte]			*
*	2) N_COL: Índice de la última columna (contando el cero). [1 byte]		*
* 	3) SEEKF: Índice de la fila buscada (contando el cero). [1 byte]		*
* 	4) SEEKC: Índice de la fila buscada (contando el cero). [1 byte]		*
*	5) TAM_CEL: Tamaño de cada celda (en bytes). [1 byte]				*
*	6) TAM_FIL: Tamaño de cada fila (en bytes). [1 byte]				*
*	7) matriz: posición de memoria inicial de la matriz. [2 bytes]			*
* 											*
* Consideraciones: Se deben liberar 8 bytes luego de invocar esta subrutina, no devuelve*
*	valores por el stack, solo por el registro D.					*
*	Si ocurre un error (elemento buscado fuera del rango de la matriz), la subrutina*
* 	devuelve el carry seteado en 1							*
*****************************************************************************************
	org	$2600		escribo la subrutina en la posición de memoria 2600
get_cell	EQU	*
	pshx			hago backup de X
	tsx			ubico al puntero X en la posición del Stack Pointer
	pshy			backup de Y
	psha			backup de A
	pshb			backup de B

	jsr	chk_status	voy a la subrutina chk_status
	bcs	error		si el carry está seteado en 1, hubo error (fuera de rango), entonces salgo
	ldy	4,x		llevo al puntero Y a la posición de memoria de la matriz
	ldaa	9,x		cargo en A el valor de la fila a buscar
	ldab	6,x		cargo en B el tamaño de cada fila
	mul			multiplico los valores
	aby			muevo al puntero Y esa cantidad de espacios de memoria
	ldaa	8,x		cargo en A el valor de la columna a buscar
	ldab	7,x		cargo en B el tamaño de cada celda
	mul			multiplico los valores para obtener el desfase de posiciones de memoria
	aby			avanzo el puntero Y esa contidad de posiciones de memoria
	ldd	0,y		guardo el valor presente en esa posición en el registro D

error	pulb			recupero el backup de B
	pula			recupero el backup de A
	puly			recupero el backup de Y
	pulx			recupero el backup de X
	rts			retorno de la subrutina

*****************************************************************************************
*			SUBRUTINA CHK_STATUS						*
*											*
* Esta subrutina es utilizada dentro de GET_CELL para verificar que los valores 	*
* ingresados de fila y columna sean válidos.						*
* Utiliza los mismos parámetros de la subrutina get_cell, respetando las posiciones	*
* del Stack Frame de dicha subrutina, por lo cual no es necesario pasarle parámetros	*
* dado que utiliza el Frame Pointer de la subrutina anterior				*
* 	- Funcionamiento: Si los valores buscados en la matriz exceden el rango de 	*
*			  la misma, entonces la subrutina devuelve el carry en 1	*
*	- No hace falta liberar el stack luego de invocarla				*
*****************************************************************************************
	org	$2050		voy a la posición de memoria 2500
chk_status	EQU	*
	ldaa	11,x		cargo A con N_FIL, el nro de la última fila
	ldab	9,x		cargo B con SEEKF, el nro de la fila a buscar
	sba			Comparo N_FIL con SEEKF (A = N_FIL - SEEKF)
	bcs	retorna		Si el carry está seteado (eso significa SEEKF > N_FIL), retorna con error (carry seteado en 1)
*				Si no no hay error con las filas, pruebo con las columnas
	ldaa	10,x		cargo A con N_COL, el nro de la última columna
	ldab	8,x		cargo B con SEEKC, el nro de la columna a buscar
	sba			Comparo N_COL con SEEKC (A = N_COL - SEEKC)

retorna	rts			retorno de la subrutina con el último valor del carry


*********************************************************
*		ZONA DE MEMORIA VOLATIL			*
* Aquí se encuentran la matriz y la zona del stack	*
*********************************************************
	org	RAM		voy a la zona de memoria declarada
matriz	RMB	FILAS*COLS*TAM_CEL		reservo el espacio de memoria para la matriz
stack	RMB	TAM_STK		reservo el espacio de memoria para el stack
stk_ini	EQU	*-1		obtengo la primera posición del stack

	end